\documentclass[a4paper,10pt]{book}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{bussproofs}
\usepackage{amsmath}
\usepackage{stmaryrd}

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
%\newcommand{\llbracket}{ \llbracket }
\newcommand{\sem}[2]{ \llbracket#1\rrbracket_{#2} }
%\AxiomC{$M=M'$}  
\newcommand{\AxioM}[1]{ \AxiomC{$#1$} }
\newcommand{\rarr}{ \rightarrow }
%\usepackage{fontspec}
%\setmainfont[Ligatures={TeX,Common}]{Linux Libertine O}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\geometry{margin=10mm}

\renewcommand{\tt}{ tt }
\newcommand{\ff}{ ff }

\begin{document}

Dana Scott:  A type-theoretic alternative to ISWIM, CUCH and OWHY (1969, published my TCS in 1993).

\begin{itemize}
\item ICWM by Lundin
\item CUCH is shorten of Curry+Church.
\item OWHY (Oh, what have you)
\end{itemize}

Semantics can be 
\begin{itemize}
\item opertaional (how we evaluate it, abstract machine)
\item logical (describe properties of an object.
\item denotational (words denote some reality; sets which also have formal language)
\item games (actions and reactions from the environment)
\end{itemize}

denotational semantics is often translation from programming languge to set theory. For programmers 
langauges are ``easy`` but set theory is ``hard``.

\footnote{Long very weird history about inventing ``a new math`` by americans to compete with USSR.
And this new math started from teaching sets in schoold as basis of mathematics}

Kesarev loh
\chapter{Simply typed $\lambda$-calculus}

Types: $\sigma ::= i | \sigma \rarr \sigma$

We denote translation as $\sem{\cdot}{}$.

Semantic brackets: $\sem{i}{} = A_{\tau}^{A_\sigma} = A_i $, 
where $i$ is a syntax object and $A$ is arbitrary set.

\paragraph{}
Grammar (in Church-style\footnote{In Curry-style variable have no types}): 
\begin{itemize}
 \item terms $M ::= x | MM | \lambda x . M$
\end{itemize}
All types are in $\Pi$, and $type(x) = \sigma$ when $x$ is a variable. For every $\sigma$ there 
are infinity many veriables of that type. We will write $x^\sigma$ which means that variable has 
type $\sigma$.



$\llbracket i -> \tau \rrbracket = \{all (total) functions form A_\sigma to A_\tau\} $
where functions are subsets of pairs  from $A_\sigma \times A_\tau$.

% Тут полный пиздец с правилами
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$x^\sigma : \sigma $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$M : \sigma \rarr \tau$} 
\AxiomC{$N: \sigma$} 
\BinaryInfC{$MN : \tau$}
\end{prooftree}

\begin{prooftree}\AxiomC{$M: \tau$}
\AxiomC{}
\BinaryInfC{$(\lambda x^\sigma . M) : \sigma \rarr \tau$}
\end{prooftree}



\section{Abstract \& concrete syntax}
In sematics we usually think about abstract syntax. which means a lot of conventions
for example, $\lambda x . x y$ can be lambda from $x$ to $x y$ or identity function applied to $y$.
We need derivation trees to be sure.

% Тут картинка которую я пока не умею рисовать в техе. Отлично, можно отдохнуть.
Another approach instead of derivation is DeBruijn indexes.

\begin{prooftree}
\AxiomC{}
\AxiomC{$\llbracket M\rrbracket \in A_\sigma$}
\BinaryInfC{$\llbracket x^\sigma\rrbracket_\rho = \rho(x)\}$
and $\rho : Var \rarr Union A_\sigma$ $\forall \sigma \in \Pi$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\llbracket MN\rrbracket_\rho = \llbracket M\rrbracket\rho (\llbracket N\rrbracket\rho)$}
\AxiomC{}
\BinaryInfC{}
\end{prooftree}

Where $\llbracket M\rrbracket_\rho \in {A_\tau}^{A_\tau}$ etc

$\sem{\lambda x^\sigma . M}{\rho} = (a \mapsto \sem{M}{\rho_{[x \mapsto a]}}) = lambda a [M]\rho[x \mapsto a]$

$\rho[x \mapsto a] \rho(a)$ when $x \neq y$

Proposition. If M is well-typed of type $\sigma$ then $\llbracket M\rrbracket_\rho \in
A_\sigma$ where $\rho$ is a var. environment

\subsection{lemma}
% тут лемма
%TODO: переписать с тетради


\section{Two views}
\begin{itemize}
 \item Sets and functions as a semantics of $\lambda$-calculus.
 \item $\lambda$-calculus is a language to denote sets and functions.
\end{itemize}

Expressivity: how many functions can be defined?

We started from finite sets and built a finite theory from finite types. And let's say we are given a function from finite set to finite set (we can describe it as finite set of pairs). Is this functions $\lambda$-describable.

Let's look: we have a type $i \rightarrow i$. Can we describe function 
$\{T \rightarrow T, F \rightarrow F\}$? Yes, identity for booleans. What about
$\{T \rightarrow T, F \rightarrow T\}$? No.

It's proven that the task is indecidable.

\section{Equations}
\begin{prooftree}
 \AxiomC{}
 \AxiomC{}
 \BinaryInfC{$M=M$}
 %\DisplayProof
\end{prooftree}

\begin{prooftree}
 \AxiomC{$M=N$}
 \AxiomC{$M=P$}
 \BinaryInfC{$M=P$}
 %\DisplayProof
\end{prooftree}

\begin{prooftree}
 \AxiomC{N=M}
 \UnaryInfC{M=N}
\end{prooftree}

It were equivalence relations

\begin{prooftree}
 \AxiomC{$M=M'$}
 \AxiomC{$N=N'$}
 \BinaryInfC{$MN=M'N'$}
\end{prooftree}

\begin{prooftree}
 \AxioM{M=M'}
 \UnaryInfC{$\lambda x . M = \lambda x . M'$}
\end{prooftree}

It were congruence rules.

\begin{prooftree}
 \AxioM{}
 \UnaryInfC{$(\lambda x . M)N = M[N/x]$}
\end{prooftree}

$\beta$-reduction.

\begin{prooftree}
 \AxiomC{$y \notin FV(M)$}
 \UnaryInfC{$\lambda x . M = \lambda y . M[y/x]$}
\end{prooftree}
$\alpha$-conversion


\begin{prooftree}
 \AxiomC{$x \notin FV(M)$}
 \AxiomC{$M: \sigma \rightarrow \tau$}
 \BinaryInfC{$M = \lambda x^\sigma . M x $}
\end{prooftree}
$\eta$-something


Are thiese rules correct?

Are this rules complete? (Yes, proved by Fridman).

\paragraph{}
Want: if $M=N$ can be defined then $\sem{M}{\rho} = \llbracket N \rrbracket_\rho$ for any $A_i$  and any $\rho$

After that equivalence and congruence rules are become trivial.

Let's prove that other axioms are OK, (not really weird, sanely chosen ot something like tath).



% $\llbracket (\lambda x .M)N\rrbracket _\rho$ =
% $\llbracket (\lambda x .M)\rrbracket_\rho (\llbracket N\rrbracket_\rho)$ =
% $(a \mapsto \llbracket M\rrbracket\rho[x->a]) (\llbracket N\rrbracket_\rho)$ =
% $\llbracket M \rrbracket _\rho [x -> \llbracket N\rrbracket_\rho]$ 


(Capture avoiding) Substituition Lemma.
$\llbracket M[N/x\rrbracket_\rho = \llbracket M\rrbracket_{\rho
[x \mapsto \llbracket N\rrbracket_\rho]}$

% тут снова картинка чтобы показать композиционность

%байка про то, как в лиспе неправильно сделано подстановки, а Схема всё поправила.
% when you write function it may contain free variable. When we use it later on, LISP
% looks for it in the environment where we use this function
\begin{enumerate}
\item $x[N/x] := N$
\item $y[N/x] := y, y \neq x$
\item $(PM)[N/x] := (P[N/x]) (M[N/x])$
\item $(\lambda x . M)[N/x] := (\lambda x . M)$
\item $(\lambda y . M)[N/x] := (\lambda y . M)[N/x]$ when $y \not\in FV(N)$
\item $(\lambda y . M)[N/x] := \lambda z . (M[z/y])[N/x]$ when $y \in FV(N), z \not\in FV(N) \cup FV(M) \cup \{x\}$
\end{enumerate}

Proofs
\begin{enumerate}
 \item obvious :)
 \item obvious :)
 \item obvious :)
 \item 
 \item The 5th case:

when $y \not\in FV(N)$

$(\lambda y . M)[N/x] = (a \mapsto \llbracket  M[N/x] \rrbracket_{\rho[y \mapsto a]})$

using lemma hypothesis

$ = (a \mapsto \llbracket M\rrbracket_{\rho[y \mapsto a, x \mapsto \llbracket [N/x] \rrbracket_{\rho[z \mapsto a] }]}$


\item 
Now we will prove for the most difficult case (6th) ($\alpha$-equivalence) and others will be exercises.

$\llbracket \lambda z . M[z/y][N/x]\rrbracket_\rho = (a \mapsto 
 \llbracket  M[z/y][N/x] \rrbracket_{\rho[z \mapsto a]})$

using lemma hypothesis
 
$ = (a \mapsto \llbracket M[z/y]\rrbracket_{\rho[z \mapsto a, x \mapsto \llbracket N \rrbracket_{\rho[z \mapsto a] }]})$

symplify

$(a \mapsto \llbracket M[z/y]\rrbracket_{\rho[z \mapsto a, x \mapsto \llbracket N \rrbracket_\rho ]})$

by hypothesis

$(a \mapsto \llbracket M\rrbracket_{\rho[z \mapsto a, x \mapsto \llbracket N \rrbracket_\rho,y \mapsto\llbracket z\rrbracket_{\rho[z \mapsto a, x \mapsto \llbracket N\rrbracket]_\rho ]}})$

symplify

$(a \mapsto \llbracket M\rrbracket_{\rho[z \mapsto a, x \mapsto \llbracket N \rrbracket_\rho,y \mapsto a]})$

symplify

$(a \mapsto \llbracket M\rrbracket_{\rho[         x \mapsto \llbracket N \rrbracket_\rho,y \mapsto a]})$

by definition
$\llbracket \lambda y M \rrbracket_{\rho[x \mapsto \llbracket N\rrbracket_\rho]}$

\end{enumerate}



Some observations

Lambda-calculus doesn't specify what exactly $i$ is. We can suppose that $A_i=\emptyset$. Then
$A_{i\rightarrow i} = A_i^{A_i} = \{ \emptyset \}$ which is a set of size 1. $A_{(i\rightarrow i)\rightarrow i} = { \emptyset }$. i.e. cardinality $|A_{(i\rightarrow i)\rightarrow i} | = 0 $.

Do we have any other ways to construct $A_i$ to be able to construct lambda terms?

$\lambda$-calculus is a way to write intuitionistic proofs when we have logic with only implication. 
 $(\phi \rightarrow \phi)\rightarrow \phi$ is a tautology

But when we use empty set as $A_i$ we can get a \textit{classical} tautology which is not describably by $\lambda$-term.

\subsection{}
We need a one thing for completeness proof.

Completeness: If $\forall$ $A_i$ and $\forall$ $\rho$: $\sem{M}{\rho}$ then $M=N$ in 
$\alpha,\beta\eta$ sense.

Fridman's compeleteness theorem
If for $A_i=NN$ andnd all $\rho$: $\sem{M}{\rho}$ then $M=N$ in 
$\alpha,\beta\eta$ sense.

For finite set we can get lambda-terms which will not be $\alpha,\beta\eta$ equivalent. There is not enough room for terms.

It's rather difficult to proof Fridman's theorem straightforwardly.

\subsection{Henkin model for $\lambda$-calculus}
The idea is to select not the whole subset but a $A_{\sigma \rightarrow \tau} \subseteq {A_\tau}^{A_\sigma}$.

Let's define sematics for application:
$\sem{MN}{\rho} = \sem{M}{\rho}(\sem{N}{\rho})$.

$\sem{\lambda x . M}{\rho} = (a \mapsto \sem{M}{\rho[x \mapsto a]})$ which is $A_\sigma \rightarrow A_\tau$
The problem is that right part can be not in the chosen subset. And it's difficult to check this because the 
set has infinite size.

Let's suppose that $A_i$ is partially ordered set and
$A_{\sigma \rightarrow \tau} = \{ f: A_\sigma \rightarrow A_\tau | 
\forall x <= y \in A_\sigma f(x) <= f(y)\}$
we take all monotone functions and in this case the problem does not occur (prove is an exercise).

At least the things we chosen should behave as functions, we need to be able to apply them.
$\forall \sigma, \tau app_{\sigma,\tau} : A_{\sigma \rightarrow \tau} \times A_{\sigma} 
\rightarrow A_{\tau}$

Extensibility: $\forall f,g \in A_{\tau \rightarrow \tau}$ $(\forall x \in A_{\sigma}: app(f,x) = app(g,x)) \Rightarrow f = g$, i.e. functions are the same if they behave the same.

$\forall \sigma,\tau$  $ab_{\sigma,\tau}: {A_\tau}^{A_\sigma} \rightharpoonup A_{\sigma \rightarrow \tau}$ (surjection).

$app (ab(f), x) = f(x)$

let $f: f: A_{\sigma} \rightarrow A_{\tau}, g \in A_{\sigma \rightarrow \tau}, 
(\forall x \in A_{\sigma} f(x) = app(g,x)) \Rightarrow ab(f) = g$

\section{Some notes about 1st day exercises}
\begin{itemize}
 \item 
 \item 
 \item Church typing: every var has a fixed type. Curry typing: terms are untyped, types are assigend
 The task was too typecheck $TT$ where $T=\lambda f \lambda x f(f(f x))$. The answer is 
 $(\alpha \rightarrow \alpha) \rightarrow (\alpha \rightarrow \alpha)$.
 
\begin{prooftree}
\AxiomC{$f$}
\AxiomC{$x$}
\BinaryInfC{$f x$}
\AxiomC{$f$}
\BinaryInfC{$f (f x)$}
\AxiomC{$f$}
\BinaryInfC{$f(f(f x))$}
\UnaryInfC{$\lambda f^3 x$}
\UnaryInfC{$\lambda f \lambda x f^3 x$}
\end{prooftree}
... and long exlanation about Milner's type reconstruction alrorithm, occurs check and that 
$A \neq a \rightarrow B$ for any \textit{finite} $A$.

Exercise 4.
$A_i$ is o.o. set. 

%TODO

Lemma. $x \leq y$, $f \leq g$ then $f(x) \leq g(y)$.  Proof. let's put $f(y)$ in the middle



Now 
$\sem{\lambda x . M}{\rho}$ = $(a \mapsto \sem{M}{\rho[x \mapsto a]})$ 

$a \leq b$ : $\sem{M}{\rho[x \mapsto a]} \leq \sem{M}{\rho[x \mapsto b]}$

by induction of the structure of M.

Application: $M \equiv x$ $M\equiv y$ $M=NP$

$\sem{M}{\rho[x \mapsto a]} \leq \sem{N}{\rho[x \mapsto b]}$ 

Lambda-abstraction:
$M = \lambda y . N$, $\sem{\lambda y N}{\rho[x \mapsto a]} = (c \rightarrow \sem{N}{\rho[x\mapsto a, ]})$

$\rho \leq \rho' if \forall x \in Var \rho(x) \leq \rho'(x)$

$\sem{M}{\rho} \leq \sem{M}{\rho'}$ And now a random question where we use antimonotonicity for ordered relation 
which nobody did get.


\end{itemize}


\section{DAy 2}
Back to completness proof. Now we will chose only one model and only one $\rho$ to show 
$\alpha, \beta, \eta$ equivalence. The general technique is to make a completness proof for a new caculus 
to be sure that we listed enough rules in it.

Termmodel: $S_\sigma = $ all terms of type $\sigma$ $ / \alpha\beta\eta$. So we introduce equivalence classes.

$[x^\sigma] \in S_\sigma$. Also $(\lambda x .x) x$ is in the same class, so $S\sigma$ is infinite. 
$[y^\sigma]$ is another class,


$\forall \sigma |S_\sigma| $ is countable but infinte.

$app([M],[N]) = [MN]$ by definition.

in case when $[M]=[M']$ and $[N]=[N']$ we need to prove that $app([M],[N]) = [M'N']$

We had a rules
\begin{prooftree}
 \AxiomC{$ M=M'$ in $\alpha\beta\eta$ sense}
 \AxiomC{$ M=N'$ in $\alpha\beta\eta$ sense}
 \BinaryInfC{$ MN=M'N' $ in $\alpha\beta\eta$ sense}
\end{prooftree}


% И тут вопрос от Вяткина, который никто не понял кроме препода
% Напомнить Диме что-то меня спросить про офис где-то

Showing extensionality.  When we ouck two functions from same class, and if they behave same
they should be equal.

$[M], [M'] \in S_{\sigma \rightarrow \tau}$
Assume that $app([M],[N]) = app([M'],[N]) \forall [N]\in S_{\sigma}$. We need to show that $[m]$ and $[M']$ 
are $\alpha\beta\eta$-equal. We will use particular $[x^\sigma]$ for $[N]$. 
Now $[Mx] = [M'x]$ are the same or
in another words $Mx = M'x$ are $\alpha\beta\eta$-equal. By congruence rules we can add $\lambda$: 
$\lambda x M x = \lambda x . M' x$ 
and $M$ is $\eta$-equal $\lambda x . M x$ 
and the same for $M'$. We suppose that 
$x$ doesn't occur in $M$ and we need a right to choose right $x$ (there we use that the sets are infinite).

Now something less trivial.

$\rho: Var \rightarrow \cup S_\sigma where \sigma is a type$


$\sem{\lambda x . M}{\rho}$ = $([N] \mapsto \sem{M}{\rho[x \mapsto [N]]}$, Now the right part should 
have a representative that behaves in the same way $\in S_{\sigma \rightarrow \tau}$. which is almost trues except the free vars in $M$
.

Claim. I can compute sematics in the different way. For any term $M$ and any $\rho$
$\sem{M}{\rho} = [M[r]]$ where ($r$ is a \textit{simultanious} substitution)
for each $x$ $r(x) \in \rho(x)$



Now exercise about about defining an simultanious substituion. the proplem was that people 
think substitution as finite-defined function from free variables in term. In math substituition is 
usually defnied as global function that behaves everywhere, and behaves as identity for variables 
that do not occur free in the specified term

Definition.
$x[r] = r(x)$

$(MN)[r] = (M[r])(N[r])$

$(\lambda x . M)[r] = \lambda z . M[r, x \mapsto z] $ where $z \not\in  FV(r(y)) for y \in FV(M)$

Simultaneous menas that we do not do full substitution, we are not going to introduce closed terms,
we only do the first level.

Proof of claim.
$M\equiv x    \sem{x}{\rho} = \rho(x)$ and $[x[r]] = [r(x)]$ and now $\rho(x) = [r(x)]$ bceause 
$r(x) \in \rho(x)$, $[r(x)] = \rho(x)$.

Lambda case is long....
$M=\lambda x . M$, $\sem{\lambda x . M}{\rho}$ = $([N] \mapsto \sem{M}{\rho_{x \mapsto [N]}})$
  
$[(\lambda x . M)[r]]$ = $[\lambda z . M[r, x:= z]]$. Now we need to look what happen when we apply
$[\lambda z . M[r, x:= z]]$ to $([N] \mapsto \sem{M}{\rho_{x \mapsto [N]}})$.

$app ([\lambda z . M[r, x:= z]], [N])$ = $[(\lambda z M [r, x:=z])N]$

 = $[(M[r, x:=z])[z:=N]]$
 
 because z is completely new 
 
 = $[M[r, x := N]]$. Now we should show that $r$ should match the environment. The only change we done
 is $x$ to N. And by induction hypothesis the $[M[r, x := N]]$ is $\sem{M}{\rho_{x \mapsto [N]}}$.
 
We did something but did not use $\alpha$ equivalence. It means that it is redundant. Exerceise to prove it.
(5 minutes later is not sure about it btw)

$\sem{M}{\rho} = \sem{N}{\rho}$ for $g(x)=[x]$ ($r(x)=x$).

 $[M]$ = $[[M[r]]$ = $\sem{M}{\rho} = \sem{N}{\rho}$ =  $[[N[r]]$ = $[N]$.
 
 and now $M=N$ in $\alpha\beta\eta$-sense.


  
\subsection{maybe something about logical relations}
Let we have $A_i$ and $B_i$ and we want to relate model based on natural numbers

$R_i \subseteq A_i \times B_i$

$R_{\sigma \rightarrow  \tau} = \{$ (f,g) $\in A_{\sigma \rightarrow \tau} \times
B_{\sigma \rightarrow \tau} |
\forall (x,y) \in R_\sigma (f(x), g(y)) \in R_\sigma \}$

Fundamental lemma for logical relations.
for any type $\sigma$, for any closed term $M$ of type $\sigma$ it's true that 
$(\sem{M}{} ^A, \sem{M}{} ^B) \in R_\sigma$

Proof. INduction over structure of general terms.

Notes. This lemma is true not only for set-theoretic model but also for Henkinmodel andnd
others.
let term is a variable. $(\sem{x}{\rho_A}^A, \sem{x}{\rho_B}^B) \in R_\sigma$

$\sem{x}{\rho_A}^A$ = $\rho_A(x)$
$\sem{x}{\rho_B}^B) = \rho_B(x)$

We can't take any $\rho$'s but any $\rho_A$,$\rho_A$ that $\forall x (\rho_A(x), \rho_b(x)) \in R_\sigma$.


% after lunch continuation
A: full ($A_{\sigma \rightarrow \tau} \subseteq A_{\tau}^{A_\sigma}$) set-theoretic model over $N$.

B: term model.

logical relation : $R_i \subseteq A_i \times B_i = N \times S_i$ such that $R_i$ is a surjective 
function from N to $S_i$\footnote{There we use that N is countable}.

Claim. For all types $\sigma$, $R_\sigma$ is a partial surjective function from $A_\sigma$ to $S_\sigma$.

\begin{itemize}
 \item $(a,t) \& (a,t') \in R_\sigma \Rightarrow t = t'$
 \item $\forall t \in S_\sigma \exists a  \in A_\sigma (a,t) \in R_\sigma$
\end{itemize}

Proof. Induction over all types .

$i$: OK, by assumption.

$\sigma \rightarrow \tau$ : $R_\sigma$,$R_\tau$ are partial surjective functions. Let's show 
$R_{\sigma \rightarrow \tau}$ has properties 1 and two.

% картинка из теорката.
% Продолжение каринки.

Need $(f,m) \in R_{\sigma \rightarrow \tau})$. Let $(A,t) \in R_\tau$

$(f(a), m(t)) = (S_\tau(R_\sigma(a)), m(t))$ = $S_\tau(m(t)), m(t)) \in R_\tau$

Now proof of Friedman's theorem.
$\sem{M}{\rho}^A = \sem{N}{\rho}^A$

Chose $\rho$: $\forall x \in Var      [x]_{\alpha\beta\eta} \in S_\sigma$
And because the logical relation is surjective  we can choose $\rho$ that

$(\rho(x), [x]_{\alpha\beta\eta}) \in R_\sigma$. We could write
$(S_\tau([x]_{\alpha\beta\eta}), [x]_{\alpha\beta\eta}) \in R_\sigma$.


$( \sem{M}{\rho}^A, \sem{M}{\rho'}^B ) \in R_\sigma$
     ||
$( \sem{N}{\rho}^A, \sem{N}{\rho'}^B ) \in R_\sigma$     

where $\rho'(x) = [x]_{\alpha}$ and now

$[M] = \sem{M}{\rho'}^B = \sem{N}{\rho'}^B = [N]$. So, $M=N$ in $\alpha\beta\eta$-sense. Qed.

There is a similar theorem in the model-view calculus (or maybe $\mu$-calculus, my hears are bad.).


\subsection{more about logical relation}

$(\sem{M}{}^A, \sem{M}{}^B) \in R_\sigma$

We could also set fundamental lemma for unary relations and single model.
$\sem{M}{} \in P_\sigma$ ($P_i \subseteq A_i$, $R_i \subseteq A_i \times B_i$). we can relate $A_i$ to himself
and get $(\sem{M}{}, \sem{M}{}, ..., \sem{M}{}) \in R_\sigma$ where $R_i \subseteq A_i \times A_i \times A_i \times ... A_i$.

Definition. $A\in A_\sigma$ is invariant of $(a,a,a,a,,.....a) \in R_\sigma$ for any logical relation $R$.

Fund. lemma. the semantcs of closed $\lambda$-term is invariant.

Question. Is every invariant element the Semantics of a closed term?   

No.

Propostition. (plotkin, 80). a $\sigma$ is a type of order 2. $A_i$ is an infinite set. Every invariant  
elment of $A_\sigma$ is $\lambda$-definable.

$ord(i) = 0$ and $ord(\sigma \rightarrow \tau) = max { ord(\sigma) + 1, ord(\tau)}$

The proof for >2 we need ''improved logical relations``. But there is a paper about it.

Theorem [Loader`93]. The $\lambda$-definability problem is undecidable.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{day 3}

Now we will got closer to computers and computable functions.

Some historic perspective.

Computable functions: $N \rightharpoonup N$ (Turing). Only nubers matters.

In 1950s we got Fortran. In 1956 Algol community firstly met, Algol58 was the academic language,
the Algol60 became 1st public knowing language. Algol68 become less pwerful than Algol60.
Formal description of the language was semantics and denotational semantics is one of approaches.

Stratchey, Landin: denotational semantics  as translation into untyped $\lambda$-calculus.
Dana Scott knowed all the problems of untyped lambda calculusbut still lambda-calculus was not 
completely unreasonable. But Scott still said that it is not right to convert something to the 
thing you can't understand. STLC is OK in this question but is not suitable for writing computable 
functions. So he extended it to LCF. Initially he did not know that will be treated as a language.

Scott (69): typed lambda calculus
Plotkin(76): LCF considered as a programming language.

LCF -- Logic of Computable Functions.

PL language converted with this approach is known as PCF but it was known as language wher ewe give 
names to set-theoretic functions. The theory of recursion was alrady very sophisticated but
Scott's approach is original: defining functions in domains.

% Platek had a thesis about recursion. It was very sphisticated and ungooglable.

\subsection{PCF}

Types: $\sigma ::= bool | i  | ...$ (where $i$ is $\iota$). The $\iota$ was initially for ''individuals``
but people think that as numbers (natural or real).

$\sigma ::= bool | i | \sigma -> \sigma$.

Terms: Scott added logical types (for bools) and other types (where for example axioms about successor
depend on the choice of $\iota$).

Terms: $M ::= x | MM | \lambda x . M | If: bool -> \sigma  -> \sigma  -> \sigma | .... $

Also $|succ | pred | zero? |...$ for logical types. And he said that ''he can't add assignment to language" :)

So he added $ | Y $.

The type of Y-combinator : $Y_\sigma : (\sigma \rightarrow \sigma) \rightarrow \sigma$.


There were names in the PCF, so we can't write \verb=let rec ...=. That's why we need Ys-combinator.

Also we need $... | \\ff | \\tt | 0$ as terms

Now we declare rewrite rules as Plotkin did (It is very brief description, which can be not full
and contain errors both because the lecturer bieleved that we all know this stuff and that
the function between what he said and \LaTeX    sometimes returns $\bot$.

\begin{prooftree}
 \AxiomC{$ $}
 \AxiomC{$ $}
 \BinaryInfC{zero? $0 \rarr \tt$}
\end{prooftree}

\begin{prooftree}
 \AxiomC{$ $}
 \AxiomC{$ $}
 \BinaryInfC{if $\tt M N \rarr M$}
\end{prooftree}

\begin{prooftree}
 \AxiomC{$ $}
 \AxiomC{$ $}
 \BinaryInfC{if $\ff M N \rarr N$}
\end{prooftree}


\begin{prooftree}
 \AxiomC{$ $}
 \AxiomC{$ P \rarr P'$}
 \BinaryInfC{if $P M N \rarr if P' M N$}
\end{prooftree}

\begin{prooftree}
 \AxiomC{$ $}
 \AxiomC{$ P \rarr P'$}
 \BinaryInfC{$ zero? P \rarr zero? P'$}
\end{prooftree}

\begin{prooftree}
 \AxiomC{$ $}
 \AxiomC{$ M \rarr M' $}
 \BinaryInfC{$ MN  \rarr MN'$}
\end{prooftree}

Call-by-name as in Haskell:
\begin{prooftree}
 \AxiomC{$ $}
 \AxiomC{$ $}
 \BinaryInfC{$ (\lambda x . M) N \rarr M[N/x]$}
\end{prooftree}

\begin{prooftree}
 \AxiomC{$ $}
 \AxiomC{$ $}
 \BinaryInfC{$zero? (k+1) \rarr \ff$}
\end{prooftree}

\begin{prooftree}
 \AxiomC{$ $}
 \AxiomC{$ $}
 \BinaryInfC{$ YM \rarr M(YM)$}
\end{prooftree}

\begin{prooftree}
 \AxiomC{$ $}
 \AxiomC{$ $}
 \BinaryInfC{$succ$ $k \rarr k+1$}
\end{prooftree}

There we do not reduce under lambda because we do not have congruence rules.

Now and example of a factorial to demonstrate that the order where we apply reductions matter.
\begin{verbatim}
letrec f = \x -> if zero? x then 1 else f(pred x) * x

we will write `\x -> if zero? x then 1 else f(pred x) * x` as M
Y(\f  \x -> if zero? x then 1 else f(pred x) * x ) : (int->int) -> (int->int)

Y(\f . M(f)) 2
(\f . M(f)) (Y(\f . M(f))) 2
now \beta step
M[Y(\f . M(f))] 2
\beta
if zero? 2 then  1 else (Y(\f . M))(pred 2) * 2
\end{verbatim}

Let's look at $Y_{int}: (int\rarr int) \rarr int$. Let's evaluate application of $Y$ to $succ$:
$succ (Y succ)$, $succ (succ (Y succ))$, ... and recursion to infinity. 
But we know that to get complete calculus we need to allow partial 
functions. So we do not say here about total functions.

\paragraph{}
Semantics of types: $\sem{bool}{} = \{\tt, \ff\} = B$, $\sem{int}{} = \{0, 1, ...\} = N$.

Sematics for terms : $\sem{M}{\rho} $ as before

$\sem{zero?}{} \in B^N$

$\sem{YM}{} = \sem{M(YM)}{} = \sem{M}{} (\sem{YM}{})$
Observation, $\sem{YM}{}$ must be a fixpoint of the $\sem{M}{}$. $Y$ should produce fixpoint for every 
definable functions. $Y$ of identity exists but $Y$ applied to $succ$ did not converge.

%%%%%%%%% some questions about primitive recursion vs. Y-combinators

And about $\mu$-recursion.
 \[
    g(a_1,...,a_n)=\left\{
                \begin{array}{ll}
                  \text{min } n\in N, \text{s.t.} f(n,a_1,...,a_n)=0\\
                  \text{undefined else}
                \end{array}
              \right.
  \]
  
  
  
%$g(a_1,...,a_n) = \mu f = \Big\{ \frac{min n\in N, s.t. f(n,a_1,...,a_n)=0}{undefined else}$

Exercise to express $\mu$ in PCF.
Solution.
\begin{verbatim}
 let rec min = \f . \x . \a . if zero? f x a then x else min f (succ x) a
\end{verbatim}
% Но я не понял почему f от 0 завершается. То ли она тотальна, то ли примитивно-рекурсивна.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{}
Now we will try to define semantics for PCF.
We kind of need to have an element to denote ``no value''. We will call it bottom: $\bot$.

bool :   true  false
           \    /
            $\bot$
            
\paragraph{}
Now we will describe functions in $\sem{bool}{}$ which have 27 functions (as functions from 3
element set to 3 element set). But we do not want semantics to explode. We want to say that 
many functions are not realistic and we do it by adding order to the set. Let's describe 
\textit{monotone} functions in this set .

% we use derivations trees to draw a graph

$\sem{bool}{} = B_\bot$

Now for natural numbers. Picture.

$\sem{int}{} = N_\bot$ 

The only way to define succ OK is when $\bot$ goes to $\bot$ because of monotonicity. Let's call
functions that goes from $\bot$ to $\bot$ as \textit{strict}.

Now 
$\sem{int \rarr int}{}$ has infinitely many and uncountable. That means that there some functions
in semantics that are undefinable. In STLC we get infinite in the power of infinity, etc... (terrible 
infinity) but in PCF the infinity doesn't grow (This is respect to PCF and not to domain theory otself).

Let's look at partial function $f: N \rightharpoonup N$ we can alsways convert it got 
$f': N_\bot \rightharpoonup N_\bot$. What the order will be here?

%  тут не штрихи, а черты сверху

$ f \leq g: \forall x f'(x) \leq g'(x)$

iff $f(x) = g(x)$ or $f(x)=\bot$. One function is better than another when ot is mpre defined that
the other. But if function below is defined we can't change values.

$c_\bot \leq \{0\mapsto 0; else \bot\}
        \leq \{0\mapsto 0; 1\mapsto 1; else \bot\}
        \leq .....
        $
        
Now let's look at F: $(int \rarr int) \rarr something$, for example        
$(int \rarr int) \rarr int$. First argument is all monotone functions. It also should be monotone,
so ``if you give me better function, I will give you better result''.

Now how we define it? If we are gotten a rubbish function $(\bot \rarr\bot)$ we can only return 
just a value (say $5$). But if we get good function, we trust it and execute it so
we can execute it only finite number of times (unless we diverge). So we will only use values of the 
argument function only on finite number of inputs.  So, we do not need to go to the top of the 
sequence above. I.e. in any HOF argument is used only finite number of times.
        
So, the $F$ is computable only if following is true:
chain $f_0 < f_1 < f_2 < ...$ will always limit the use of f: 
$lim F_n where n\in N = V f_n where n\in N$

% здесь не V а большая галка со стрелкой вверх в правой ветке.

So, if Ff returns a value, it was defined on the chain.

Def. F is Scott-continious if for all chains  $f_0 < f_1 < f_2 < ...$
the $V F(f_n) = F(Vf_n)$ for all n$\in N$.
\begin{definition}{Scott-continious.}
F is Scott-continious if for all chains  $f_0 < f_1 < f_2 < ...$
the $V F(f_n) = F(Vf_n)$ for all n$\in N$.
\end{definition}
N.B. it can be $\leq$ in the chain but it will make more difficult reasoning. There we
the notion of непрерывности but for isolated input.

Def. (D, $\leq$) is CPO (complete partial order) if for every chain $a_o <= a_1 <= ...$
there is a limit $a$: $a_n <= a$ for every $n$ and for every $b\in D$: $a_n<=b$ $a<=b$ .
and there is a least element $\bot_D$.

We had the same for $R$: supremum:

So the function $F: D \rarr E$  (where $D,E$ are CPOs) is Scott-continious 
if it is monotone and for all chains  $f_0 < f_1 < f_2 < ...$
the $V F(a_n) = F(V a_n)$ for all n $\in N$.

So, we restricted monotone function to continious ones. 

We did all of that because of we didn't get a fix-points in the original model. Let's do this.


\begin{theorem}
$D$ is CPO and $f: D \rarr D$ is Scott-continious . Then $f$ has a least fixpoint.
\end{theorem}
\begin{proof}
$\bot \leq f(\bot)$. Now we apply $f$ to both sides, and order will be preserved.

$f(\bot) \leq  f(f(\bot))$. So we get a chain
$\bot \leq f(\bot) \leq f(f(\bot)) \leq f(f(f(\bot))) \leq ....$. Because CPO

% Мы можем рисовать кубы тут.

there is a limit of this sequence. $a = Vf^n(\bot)$ where $n\in N$. 
Claim1: $a$ is a fixpoint of $f$.
Claim2: it is a least fixpoint

Let's proof claims.

$\bot \leq f(\bot) \leq f^2(\bot) \leq f^3(\bot) \leq ... Vf^n(\bot)$

$f(\bot) \leq f^2(\bot) \leq f^3(\bot) \leq f^4(\bot) \leq ... Vf^n(\bot)$

$f(Vf^n(\bot)) = Vf^{n+1}(\bot) = VF^n(\bot)$

Now proof claim2:
 
 $\bot \leq a = f(a)$
 $f(\bot) \leq f(a) = a$.
 $f^2(\bot) \leq a$.  So we showed a fixpoint which is a least fixpoint.
.
\end{proof}

$\sem1{Y}$ where Y has type $(\sigma\rarr\sigma)\rarr\sigma$,
$\sem1{Y} = (f \mapsto V f^n(\bot)$

All that we done we have done in a theoretical way without knowledge about PCF. Now we
should stuck in monotone functions and in CPOs.

Some long speach about there are very low count of categories that are with this properties.

End of the day 3.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{prooftree}
 \AxiomC{$ $}
 \AxiomC{$ $}
 \BinaryInfC{$ $}
\end{prooftree}


\end{document}
